# Migration Guide: v0.4 to v0.5

This guide covers the breaking changes and new features when upgrading from Gorkflow v0.4 to v0.5.

## Breaking Changes

### 1. Step Data Access API Changed

The `ctx.Outputs` accessor has been renamed to `ctx.Data` for clarity.

**Before (v0.4):**

```go
func handler(ctx *gorkflow.StepContext, input MyInput) (MyOutput, error) {
    var prevOutput PreviousOutput
    err := ctx.Outputs.Get(ctx.Context, "previous-step", &prevOutput)
    // ...
}
```

**After (v0.5):**

```go
func handler(ctx *gorkflow.StepContext, input MyInput) (MyOutput, error) {
    // Option 1: Use type-safe generic helper (recommended)
    prevOutput, err := gorkflow.GetOutput[PreviousOutput](ctx, "previous-step")
    
    // Option 2: Use accessor directly
    var prevOutput PreviousOutput
    err := ctx.Data.GetOutput("previous-step", &prevOutput)
    // ...
}
```

### 2. State Accessor Signature Changed

The `State.Set` method no longer requires passing `ctx.Context`.

**Before (v0.4):**

```go
ctx.State.Set(ctx.Context, "key", value)
```

**After (v0.5):**

```go
ctx.State.Set("key", value)
```

The `State.Get` signature remains unchanged:

```go
ctx.State.Get("key", &target)
```

### 3. StepContext Structure Updated

The `StepContext` struct has been updated:

**Before (v0.4):**

```go
type StepContext struct {
    Context  context.Context
    Logger   zerolog.Logger
    State    StateAccessor
    Outputs  OutputAccessor  // Old name
    RunID    string
    StepID   string
}
```

**After (v0.5):**

```go
type StepContext struct {
    Context       context.Context
    Logger        zerolog.Logger
    State         StateAccessor
    Data          StepDataAccessor  // Renamed, expanded interface
    RunID         string
    StepID        string
    Attempt       int               // New: current retry attempt
    CustomContext any               // New: user-defined context
}
```

### 4. WorkflowError is Now a Struct

When checking workflow errors, access the `Message` field instead of dereferencing.

**Before (v0.4):**

```go
if run.Error != nil {
    fmt.Println("Error:", *run.Error)
}
```

**After (v0.5):**

```go
if run.Error != nil {
    fmt.Println("Error:", run.Error.Message)
    fmt.Println("Code:", run.Error.Code)
    fmt.Println("Step:", run.Error.Step)
}
```

## New Features

### 1. Type-Safe Generic Helpers

New generic helper functions provide compile-time type safety:

```go
// Get output from previous step
output, err := gorkflow.GetOutput[MyOutputType](ctx, "step-id")

// Get input from a step
input, err := gorkflow.GetInput[MyInputType](ctx, "step-id")

// Get custom context
myCtx, err := gorkflow.GetContext[MyContextType](ctx)

// Type-safe state operations
err := gorkflow.SetTyped(ctx.State, "key", myValue)
value, err := gorkflow.GetTyped[MyType](ctx.State, "key")
```

### 2. Custom Workflow Context

Pass custom data accessible in all steps:

```go
type MyAppContext struct {
    UserID    string
    TenantID  string
    RequestID string
}

// Set context when building workflow
wf, _ := gorkflow.NewWorkflow("my-wf", "My Workflow").
    WithContext(MyAppContext{
        UserID:    "user-123",
        TenantID:  "tenant-456",
        RequestID: "req-789",
    }).
    Sequence(step1, step2).
    Build()

// Access in step handlers
func handler(ctx *gorkflow.StepContext, input MyInput) (MyOutput, error) {
    appCtx, err := gorkflow.GetContext[MyAppContext](ctx)
    if err != nil {
        return MyOutput{}, err
    }
    ctx.Logger.Info().Str("user_id", appCtx.UserID).Msg("Processing")
    // ...
}
```

### 3. Retry Attempt Tracking

Access the current retry attempt number in step handlers:

```go
func handler(ctx *gorkflow.StepContext, input MyInput) (MyOutput, error) {
    if ctx.Attempt > 0 {
        ctx.Logger.Warn().Int("attempt", ctx.Attempt).Msg("Retrying...")
    }
    // ...
}
```

### 4. Enhanced Error Types

Structured error types with more context:

```go
// WorkflowError includes detailed information
type WorkflowError struct {
    Message   string
    Code      string                 // e.g., "EXECUTION_FAILED", "TIMEOUT"
    Step      string                 // Step that caused the error
    Timestamp time.Time
    Details   map[string]interface{} // Additional context
}

// StepError for step-level failures
type StepError struct {
    Message   string
    Code      string
    Timestamp time.Time
    Attempt   int                    // Which attempt failed
    Details   map[string]interface{}
}
```

### 5. Input Access from Steps

Access input data from any previous step:

```go
func handler(ctx *gorkflow.StepContext, input MyInput) (MyOutput, error) {
    // Get what was passed TO a previous step
    prevInput, err := gorkflow.GetInput[PrevStepInput](ctx, "previous-step")
    // ...
}
```

## Migration Checklist

- [ ] Replace `ctx.Outputs.Get(ctx.Context, ...)` with `gorkflow.GetOutput[T](ctx, ...)` or `ctx.Data.GetOutput(...)`
- [ ] Replace `ctx.State.Set(ctx.Context, ...)` with `ctx.State.Set(...)`
- [ ] Update error handling to use `run.Error.Message` instead of `*run.Error`
- [ ] Consider using new type-safe generic helpers for better compile-time safety
- [ ] Consider adding custom context for cross-cutting concerns
- [ ] Run tests to verify all step handlers work correctly

## Example: Full Migration

**Before (v0.4):**

```go
func processStep(ctx *gorkflow.StepContext, input ProcessInput) (ProcessOutput, error) {
    // Get previous output
    var fetchResult FetchOutput
    if err := ctx.Outputs.Get(ctx.Context, "fetch", &fetchResult); err != nil {
        return ProcessOutput{}, err
    }
    
    // Update state
    ctx.State.Set(ctx.Context, "processed_count", len(fetchResult.Items))
    
    return ProcessOutput{Items: fetchResult.Items}, nil
}

// Check result
run, _ := eng.GetRun(ctx, runID)
if run.Error != nil {
    log.Printf("Failed: %s", *run.Error)
}
```

**After (v0.5):**

```go
func processStep(ctx *gorkflow.StepContext, input ProcessInput) (ProcessOutput, error) {
    // Get previous output (type-safe)
    fetchResult, err := gorkflow.GetOutput[FetchOutput](ctx, "fetch")
    if err != nil {
        return ProcessOutput{}, err
    }
    
    // Update state (simplified signature)
    ctx.State.Set("processed_count", len(fetchResult.Items))
    
    // Access retry info if needed
    if ctx.Attempt > 0 {
        ctx.Logger.Info().Int("retry", ctx.Attempt).Msg("Retrying process step")
    }
    
    return ProcessOutput{Items: fetchResult.Items}, nil
}

// Check result (structured error)
run, _ := eng.GetRun(ctx, runID)
if run.Error != nil {
    log.Printf("Failed: %s (code: %s, step: %s)", 
        run.Error.Message, 
        run.Error.Code, 
        run.Error.Step)
}
```

## Getting Help

If you encounter issues during migration:

1. Check the [API Reference](../api-reference/) for detailed documentation
2. Review the [Examples](../examples/) for working code samples
3. Open an issue on GitHub with your specific migration question
